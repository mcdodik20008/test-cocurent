9. Поиск в массиве с использованием ParallelStream
Описание: Напиши программу, которая ищет элемент в массиве или коллекции с использованием Stream API.

Разбей массив на части и используй parallelStream.
Поддерживай возможность работы с большими наборами данных.
Ключевые моменты:

Демонстрация понимания работы parallelStream и его ограничений.
Учет возможных проблем с конкурентным доступом.



Теория и рекомендации для выполнения задачи "Поиск в массиве с использованием ParallelStream"
1. Что такое ParallelStream
ParallelStream — это специальный вид стрима в Java,
который автоматически разбивает задачи на подзадачи и выполняет их параллельно
с использованием пула потоков ForkJoinPool.
Это удобно для обработки больших коллекций данных или массивов,
особенно когда задача легко делится на независимые части.

2. Особенности ParallelStream
Параллельная обработка:

Каждый поток обрабатывает свою часть данных.
Используется общий пул потоков, предоставляемый ForkJoinPool.
Применение:

Преобразование коллекций или массивов в Stream с помощью Arrays.stream() или .stream().
Переключение на параллельную обработку с .parallel().
Когда использовать:

Данные большие и легко разделяемые.
Операции независимы друг от друга.
**Когда не стоит использовать:

Данные малы, и накладные расходы на создание потоков превышают преимущества.
Операции зависят друг от друга.
3. Пример задачи
Допустим, нужно найти:

Первый элемент в массиве, удовлетворяющий условию.
Количество элементов, соответствующих предикату.
Максимальный элемент в массиве.
4. Пример реализации
java
Копировать код
import java.util.Arrays;
import java.util.Optional;
import java.util.Random;

public class ParallelStreamExample {
    public static void main(String[] args) {
        // Генерация большого массива случайных чисел
        int[] array = new Random().ints(10_000_000, 1, 1_000_000).toArray();

        // 1. Поиск первого числа, которое делится на 777
        long startTime = System.currentTimeMillis();
        Optional<Integer> firstDivisibleBy777 = Arrays.stream(array)
            .parallel()
            .filter(num -> num % 777 == 0)
            .findFirst();
        long endTime = System.currentTimeMillis();

        System.out.println("First number divisible by 777: " + firstDivisibleBy777.orElse(-1));
        System.out.println("Time taken: " + (endTime - startTime) + " ms");

        // 2. Подсчет количества чисел, которые делятся на 123
        startTime = System.currentTimeMillis();
        long countDivisibleBy123 = Arrays.stream(array)
            .parallel()
            .filter(num -> num % 123 == 0)
            .count();
        endTime = System.currentTimeMillis();

        System.out.println("Count of numbers divisible by 123: " + countDivisibleBy123);
        System.out.println("Time taken: " + (endTime - startTime) + " ms");

        // 3. Нахождение максимального числа
        startTime = System.currentTimeMillis();
        int maxNumber = Arrays.stream(array)
            .parallel()
            .max()
            .orElse(-1);
        endTime = System.currentTimeMillis();

        System.out.println("Max number: " + maxNumber);
        System.out.println("Time taken: " + (endTime - startTime) + " ms");
    }
}
5. Пошаговое объяснение кода
Генерация массива:

Случайный массив создаётся с помощью Random.ints().
Поиск первого элемента:

Метод findFirst() возвращает первый элемент, который соответствует условию.
Используется .filter() для задания условия.
Подсчёт элементов:

Метод count() считает количество элементов, прошедших через фильтр.
Поиск максимального значения:

Метод max() находит максимальное число в массиве.
Параллельная обработка:

Вызов .parallel() автоматически распределяет работу по потокам.
6. Рекомендации
Работа с большими массивами:

ParallelStream эффективен для массивов с количеством элементов от 10 000 и выше. Для меньших массивов лучше использовать обычный стрим.
Минимизация блокировок:

Операции в стриме должны быть чистыми (без изменения внешних переменных).
Сложные вычисления:

Если операция требует много вычислений, параллелизм даст больше прироста производительности.
Использование кастомного пула потоков:

Настройка пула через ForkJoinPool.commonPool() позволяет задать количество потоков.
7. Идеи для усложнения задачи
Обработка строковых данных:
Найди все строки, содержащие определённое слово.
Генерация статистики:
Подсчитай сумму, среднее, минимум и максимум для чисел в массиве.
Фильтрация данных:
Удаление дубликатов и подсчёт уникальных значений в массиве.
Этот пример охватывает базовые применения ParallelStream. Если нужно добавить что-то специфическое, обращайся!